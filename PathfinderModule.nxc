#ifndef __PATHFINDER__
#define __PATHFINDER__

/*******************************
 * PathFinder
 * 
 * author: Nils WeiÃŸ
 * *****************************/

/*******************************
 * Information:
 *******************************/
 
 
/*******************************
 * Includes
 *******************************/

#include "MapModule.nxc"
#include "FileIO.nxc"

/******************************
 * Defines:
 ******************************/

#define max(v1, v2) { if( v1 >= v2 ) return v1; else return v2; }
#define PathFinder_STARTPOSITION_ON_MAP
#define PathFinder_MAX_NUMBER_OF_TIME_TABLE_ENTRIES 20
#define PathFinder_INITIAL_ORIENTATION_OF_ROBOT 0
/*******************************
 * Declaration
 *******************************/
 
 struct PathFinder_timeTableEntry {
    byte xPosition;
    byte yPosition;
    char activity;
    union {
        short degreeCountForTurn;
        short distanceToDrive;
    } parameter;
 };

MapModule_Map g_PathFinder_RoadMap;
PathFinder_timeTableEntry PathFinder_timeTable[PathFinder_MAX_NUMBER_OF_TIME_TABLE_ENTRIES];
unsigned byte PathFinder_timeTableWritePointer;
unsigned byte PathFinder_timeTableReadPointer;

void PathFinder_init(void);
void PathFinder_annotateMap(const byte target);
void PathFinder_searchWay(void);
void PathFinder_writeTimeTableEntry(const byte& xPos, const byte& yPos, const char activity, const short activityParameter );
void PathFinder_writeTurnActivityEntryInTimeTable(const byte& x_Pos, const byte& y_Pos, const unsigned short destinationOrientation);

/******************************
 * Debugs
 * using LCD
 ******************************/
 
 #define Pathfinder_DEBUG	      
 #define Pathfinder_FEEDBACK	

/*******************************
 *Functions and tasks
 *******************************/

void PathFinder_init(void)
{
    FileIO_initWorkField();
    memcpy(g_PathFinder_RoadMap.map, g_MapModule_WorkField.map, SizeOf(g_MapModule_WorkField.map));
    PathFinder_timeTableWritePointer = 0;
    PathFinder_timeTableReadPointer = 0;
}

void PathFinder_writeTimeTableEntry(const byte& xPos, const byte& yPos, const char activity, const short activityParameter )
{
#ifdef Pathfinder_DEBUG
    TextOut(0,LCD_LINE6, FormatNum("Entry: %x:%x = %c -> %d ", xPos, yPos, activity, activityParameter));
#endif /* Pathfinder_DEBUG */

#ifdef Pathfinder_FEEDBACK
	PlayTone(1000,50);
#endif /* Pathfinder_FEEDBACK */

    PathFinder_timeTable[PathFinder_timeTableWritePointer].xPosition = xPos;
    PathFinder_timeTable[PathFinder_timeTableWritePointer].yPosition = yPos;
    PathFinder_timeTable[PathFinder_timeTableWritePointer].activity = activity;
    
    if(activity == 'T')
    {
        PathFinder_timeTable[PathFinder_timeTableWritePointer].parameter.degreeCountForTurn = activityParameter;
    }
    else if(activity == 'D')
    {
        PathFinder_timeTable[PathFinder_timeTableWritePointer].parameter.distanceToDrive = activityParameter;
    }
    else
    {
        //EXCEPTION
        TextOut(0, LCD_LINE1, "WriteTimeTableEntry");
        TextOut(0, LCD_LINE2, "Exception");
        TextOut(0, LCD_LINE3, "Invalid activity");
        PlayTone(TONE_C5, SEC_1);
        Wait(500);
        Stop(true);
    }
    
    
    PathFinder_timeTableWritePointer++;
    if(PathFinder_timeTableWritePointer == PathFinder_MAX_NUMBER_OF_TIME_TABLE_ENTRIES)
    {
        //EXCEPTION
        TextOut(0, LCD_LINE1, "WriteTimeTableEntry");
        TextOut(0, LCD_LINE2, "Exception");
        TextOut(0, LCD_LINE3, "write pointer overflow");
        PlayTone(TONE_C5, SEC_1);
        Wait(500);
        Stop(true);

    }
}

void PathFinder_annotateMap(const byte target)
{
     for(int y = 0; y < GLOBAL_MAP_HEIGHT; y++)
     {
             for(int x = 0; x < GLOBAL_MAP_WIDTH; x++)
             {
                     if(g_PathFinder_RoadMap.map[GLOBAL_MAP_WIDTH * y + x] == target) g_PathFinder_RoadMap.map[GLOBAL_MAP_WIDTH * y + x] = 'z';
             }
     }
     
     bool everything_done = false;
     
     while(!everything_done)
     {
             everything_done = true;
             for(int y = 0; y < GLOBAL_MAP_HEIGHT; y++)
             {
                     for(int x = 0; x < GLOBAL_MAP_WIDTH; x++)
                     {
                             if(g_PathFinder_RoadMap.map[GLOBAL_MAP_WIDTH * y + x] == ' ')
                             {
                                  everything_done = false;
                                  byte left = g_PathFinder_RoadMap.map[GLOBAL_MAP_WIDTH * y + x - 1];
                                  byte right = g_PathFinder_RoadMap.map[GLOBAL_MAP_WIDTH * y + x + 1];
                                  byte above = g_PathFinder_RoadMap.map[GLOBAL_MAP_WIDTH * (y - 1) + x];
                                  byte below = g_PathFinder_RoadMap.map[GLOBAL_MAP_WIDTH * (y + 1) + x];
                             }
                             
                             unsigned int avg = 0;
                             unsigned int count = 0;
                     
                             if(left>= 'a' && left <= 'z')
						     {
						          count++; avg += left;
                             }
						     if(right>= 'a' && right <= 'z')
						     {
							      count++; avg += right;
                             }
						     if(above>= 'a' && above <= 'z')
						     {
							      count++; avg += above;
                    	     }
						     if(below>= 'a' && below <= 'z')
						     {
							      count++; avg += below;
                             }
                             if(count > 0)
						     {
						          avg = avg / count;
							      if ((byte)avg < 'b') {avg = 'b';}
							      g_PathFinder_RoadMap.map[GLOBAL_MAP_WIDTH * y + x] = (byte)(--avg);
                             }
                     }
             }
     
     }
}

void PathFinder_writeTurnActivityEntryInTimeTable(const byte& x_Pos, const byte& y_Pos, const unsigned short destinationOrientation)
{
    static unsigned short currentOrientation = PathFinder_INITIAL_ORIENTATION_OF_ROBOT;
    unsigned short rotation = destinationOrientation - currentOrientation;
    if(abs(rotation) <= 180) 
    {
        PathFinder_writeTimeTableEntry(x_Pos, y_Pos, 'T', rotation);
        return;
    }
    
    rotation = 180 - rotation;
    
    if(rotation < 360)
    {
        PathFinder_writeTimeTableEntry(x_Pos, y_Pos, 'T', rotation);
        return;
    }
    
    rotation = rotation - 360;
    PathFinder_writeTimeTableEntry(x_Pos, y_Pos, 'T', rotation);
        
}

void PathFinder_searchWay(void)
{
     unsigned int x_Pos, y_Pos;
		 for(unsigned int y = 0; y < GLOBAL_MAP_HEIGHT; y++)
     {
			     for(unsigned int x = 0; x < GLOBAL_MAP_WIDTH; x++)
           {
				         if(g_PathFinder_RoadMap.map[GLOBAL_MAP_WIDTH * y + x] == 'S') {x_Pos = x; y_Pos = y;};
           }
		 }
		 
		 byte searching = true;
		 unsigned int steps = 0;
		 
		 while(searching)
		 {
            byte left = g_PathFinder_RoadMap.map[GLOBAL_MAP_WIDTH * y_Pos + x_Pos - 1];
            byte right = g_PathFinder_RoadMap.map[GLOBAL_MAP_WIDTH * y_Pos + x_Pos + 1];
            byte above = g_PathFinder_RoadMap.map[GLOBAL_MAP_WIDTH * (y_Pos - 1) + x_Pos];
            byte below = g_PathFinder_RoadMap.map[GLOBAL_MAP_WIDTH * (y_Pos + 1) + x_Pos];
		 }
		 
     byte maxValue = max( max( left, right ), max( above , below ));
     
     if(maxValue == left)
     {
            PathFinder_writeTurnActivityEntryInTimeTable(x_Pos, y_Pos, 270);
            while(true)
            {
                  byte current = g_PathFinder_RoadMap.map[GLOBAL_MAP_WIDTH * y_Pos + x_Pos];
                  byte next = g_PathFinder_RoadMap.map[GLOBAL_MAP_WIDTH * y_Pos + x_Pos + 1];
                  if(current == 'z') searching = false;
                  
                  if(current >= next || next == '#')
                  {
                       PathFinder_writeTimeTableEntry(x_Pos, y_Pos, 'D', steps);
                       steps = 0;
                       break;
                  }
                  else
                  {
                       g_PathFinder_RoadMap.map[GLOBAL_MAP_WIDTH * y_Pos + x_Pos] = 'X';
                       x_Pos++;
                       steps++;
                  }

            }
     } else if(maxValue == right)
     {
            PathFinder_writeTurnActivityEntryInTimeTable(x_Pos, y_Pos, 90);
            while(true)
            {
                  byte current = g_PathFinder_RoadMap.map[GLOBAL_MAP_WIDTH * y_Pos + x_Pos];
                  byte next = g_PathFinder_RoadMap.map[GLOBAL_MAP_WIDTH * y_Pos + x_Pos - 1];
                  if(current == 'z') searching = false;
                  
                  if(current >= next || next == '#')
                  {
                       PathFinder_writeTimeTableEntry(x_Pos, y_Pos, 'D', steps);
                       steps = 0;
                       break;
                  }
                  else
                  {
                       g_PathFinder_RoadMap.map[GLOBAL_MAP_WIDTH * y_Pos + x_Pos] = 'X';
                       x_Pos--;
                       steps++;
                  }

            }
     } else if(maxValue == above)
     {
            PathFinder_writeTurnActivityEntryInTimeTable(x_Pos, y_Pos, 0);
            while(true)
            {
                  byte current = g_PathFinder_RoadMap.map[GLOBAL_MAP_WIDTH * y_Pos + x_Pos];
                  byte next = g_PathFinder_RoadMap.map[GLOBAL_MAP_WIDTH * (y_Pos + 1) + x_Pos];
                  if(current == 'z') searching = false;
                  
                  if(current >= next || next == '#')
                  {
                       PathFinder_writeTimeTableEntry(x_Pos, y_Pos, 'D', steps);
                       steps = 0;
                       break;
                  }
                  else
                  {
                       g_PathFinder_RoadMap.map[GLOBAL_MAP_WIDTH * (y_Pos + 1) + x_Pos] = 'X';
                       y_Pos++;
                       steps++;
                  }

            }
     } else
     {
            PathFinder_writeTurnActivityEntryInTimeTable(x_Pos, y_Pos, 180);
            while(true)
            {
                  byte current = g_PathFinder_RoadMap.map[GLOBAL_MAP_WIDTH * y_Pos + x_Pos];
                  byte next = g_PathFinder_RoadMap.map[GLOBAL_MAP_WIDTH * (y_Pos - 1) + x_Pos];
                  if(current == 'z') searching = false;
                  
                  if(current >= next || next == '#')
                  {
                       PathFinder_writeTimeTableEntry(x_Pos, y_Pos, 'D', steps);
                       steps = 0;
                       break;
                  }
                  else
                  {
                       g_PathFinder_RoadMap.map[GLOBAL_MAP_WIDTH * (y_Pos - 1) + x_Pos] = 'X';
                       y_Pos--;
                       steps++;
                  }

            }
     } 
}

#endif
