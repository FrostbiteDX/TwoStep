#ifndef ___MOTORMODULE___
#define ___MOTORMODULE___

/*******************************
 * MotorModule
 *
 * author: Florian Laufenböck
 * *****************************/

/*******************************
 * Information:
 *******************************/
 // to start the MototModule call only  MU_start_all_features() !
 // der Fehler bei der Fahrt beträgt bei gefahrenen 2000° ca. 2°
 // -> immer aufrunden oder immer abrunden?
/*******************************
 * Beispielkarte der Umgebung:

     0123456789ABCD
	0##############
	1#	  S	      #
	2##   #####   #
	3#	  11 	  #
	4#			  #
	5#   ####    2#
	6#	    #    2#
	7#	    #     #
	8#   ##########
	9#   #        #
	A#   #   33   #
	B#   #        #
	C#            #
	D##############
	------------->x - koordinate
    und von up to down ist y-koordinate
    -> S = 5/1
    außerdem gilt: der Startwinkel ist entlang der positiven y achse, sodass beim Start vom Roboter aus vorne 0° sind
    *
    *
    **************************/



/*******************************
 * Includes
 *******************************/
// needs the SensorModule, because of the compass
#include "SensorModule.nxc"
#include "TimersAndEvents.nxc"


/*******************************
 * Declaration
 *******************************/

/* struct _MU_data
 *
 * unsigned int MU_x_pos:	liefert die aktuelle x-position des Fahrzeugs allein aufgrund der Odometrie zurück
 * unsigned int MU_y_pos: 	liefert die aktuelle y-position des Fahrzeugs allein aufgrund der Odometrie zurück
 * unsigned int MU_angle:	liefert den Winkel zurück, in dem das Fahrzeug im Raum steht, zurück
 *
 * short MU_sin_angle:		liefert den Winkel zurück, der zwischen der Gerade, die die Startposition mit der aktuellen Position verbindet, und der y-Achse zurück
 * float MU_distance:		liefert den abstand(luftlinie) zum Start zurück; benutzt dafür x-pos, y-pos
 */
struct _MU_data
{
	unsigned int MU_x_pos;
	unsigned int MU_y_pos;
	long MU_angle;

	long MU_sin_angle;
	float MU_distance;
};

bool global_someth_exist;	// globale Variable für die Tatsache, ob ein Getränk vorhanden ist
long global_Dig0;	// das ist der winkel, der "0" ist, also der 0 winkel von dem ich alles brauche, wichtig: NUR BEIM START INITIAL BELEGEN

/* function: MU_drive_forward
 * gets: weg in cm der zurückgelegt werden muss
 * fährt den Weg in cm ab, fährt nur geradeaus, sodass keine komplexen Bewegungen entstehen
 * hat einen special_mode mit dem ich einfach so lange fahren kann, wie ich will (bzw. Event wird geworfen...)
 * liefert false zurück, wenn iwas schiefgegangen ist(hinderniss, lange keine signal, bin auf farbe gesstossen)
 * schmeißt am Ende der Ausführung ein Event, sodass der Tachometer gelöscht werden kann
 */
bool MU_drive_forward(const short &cm, bool special_test = false);

/* functin: MU_drive_backward
 * gets: weg in cm, der zurückgelegt werden soll
 * fährt den weg rückwärts ab, keine komplexen Bewegungen
 * hat einen special_mode mit dem ich einfach so lange fahren kann, wie ich will (bzw. Event wird geworfen...)
 * ruft einfach nur MU_drive_forward mit negativen Wert auf
 *  liefert false zurück, wenn iwas schiefgegangen ist(hinderniss, lange keine signal, bin auf farbe gesstossen)
 * schmeißt am Ende der Ausführung ein Event, sodass der Tachometer gelöscht werden kann
 */
bool MU_drive_backward(const short &cm, bool special_test = false);

/* function: MU_drehen_by_angle
 * gets: den Winkel den er sich drehen soll(positiv oder negativ)
 * 											wobei: positiv = in Uhrzeigersinnn, negativ = gegen Uhrzeigersinn
 * dreht sich um den Winkel um die eigene Achse, sodass der Mittelpunkt des Robos immer gleich ist
 *  liefert false zurück, wenn iwas schiefgegangen ist(hinderniss, lange keine signal, bin auf farbe gesstossen)
 * nach fertigem drehen wird der Tachocounter gelöscht!!!!
 */
bool MU_drehen_by_angle(const short &angle);

/* function: MU_drehen_by_degree
 * hier geht es darum,dass das Fahrzeug sich in einen bestimmten Winkel abhängig vom Kompass dreht
 * der Kompasswinkel sei 0, wenn das Fahrzeug in richtung positiver x-Richtung schaut
 * er entwickelt sich in richtung uhrzeigersinn
 */
bool MU_drehen_by_degree(const short &degree);

/*function: MU_start_all_featurs
 * kriegt keine Variablen
 * testet ob beide Motoren in A und C eingesteckt sind
 * startet den Task MU_informations
 * liefert false zurück, sollte iwas nicht wie gewünscht laufen
 */
bool MU_start_all_features();

/* Task: MU_informations
 * wird einmal initial gestartet
 * legt die Daten der Odometrie einmal inital an und verwaltet diese
 * läuft in einer Endlosschleife
 */
task MU_informations();


/******************************
 * Defines:
 ******************************/
#define MU_GLOBAL_X_0	6
#define MU_GLOBLAL_Y_0	1
#define MU_GLOBAL_ANGLE_0	0	// veränderbar, wenn der Roboter inital einmal hingestellt wurde
#define GLOBAL_1_SEKTOR 25	// definition wie groß ein Sektor im Raum ist
#define MU_GLOBAL_ANGLE_MOTOR 360	// Winkel, damit sich das Rad einmal dreht
#define MU_GLOBAL_UMFANG 13.5	// umfang des Rades
#define MU_GLOBAL_DRIVE1 (MU_GLOBAL_ANGLE_MOTOR / MU_GLOBAL_UMFANG) 	// Winkel um einen cm zurückzulegen
#define MU_GLOBAL_WHEEL	(MU_GLOBAL_DRIVE1 * GLOBAL_1_SEKTOR)	// Winkel um 25cm zurückzulegen
#define MU_GLOBAL_MAXSPEED 75
#define MU_GLOBAL_DEGREE_ONESTEP 50		// gibt die Grad an, die ich bei einer Umdrehung fahren will
#define GLOBAL_MOTOR2 OUT_A
#define GLOBAL_MOTOR1 OUT_C
#define GLOBAL_MOTOR12 OUT_AC
#define MU_GLOBAL_STOPandGO 400		// fester Wert, den das Fahrzeug fürs Beschleunigen und Bremsen braucht
#define MU_lokal_Beschleunigung (MU_GLOBAL_STOPandGO / MU_GLOBAL_DEGREE_ONESTEP);	// im moment bei 8, lass ma mal so
#define MU_GLOBAL_MINSPEED 30

#define MU_GLOBAL_FEHLERKORREKTUR	// bleibt erstmal unitialisiert, weil die Korrektur übern Kompass erstmal rausfliegt

/******************************
 * Debugs
 * using LCD_LINE 1 and 2
 ******************************/
 #define MU_debug	// debug klausel
 #define MU_feedback	// klausel, die bestimmt, wann feedback vom Robo nach außen gegeben wird


/*******************************
 * Timer and Events for the Motormodule	
 ******************************/
#define GLOBAL_EVENT_MU_READING 0x80	// sollte dieses Event gesetzt sein, dann dürfen Informationen ausgelesen werden, ist nur der Fall, wenn man geradeaus oder Rückwärts fährt


/*******************************
 * Initialisation
 ******************************/
_MU_data MU_data_info;

/*******************************
 *Functions and tasks
 *******************************/

bool MU_drehen_by_degree(const short &degree)
{
	short difference = global_Dig0 - SU_Values.iCurrentDeg;	// erstmal die differenz auslesen, die mir fehlt
	RotateMotorEx(GLOBAL_MOTOR12,10,(difference * MU_GLOBAL_FEHLERKORREKTUR),100,false,false);
	ResetRotationCount(GLOBAL_MOTOR12);
}

bool MU_drehen_by_angle(const short &angle)
{
	RotateMotorEx(GLOBAL_MOTOR12,10,angle,100,false,false);
	ResetRotationCount(GLOBAL_MOTOR12);
}

bool MU_drive_backward(const short &cm, bool special_test = false)
{
	MU_drive_forward(-cm, special_test);
}

bool MU_drive_forward(const short &cm, bool special_test = false)
{
	ResetRotationCount(GLOBAL_MOTOR12);
	Event_setEvent(GLOBAL_EVENT_MU_READING);

	long dig0_here = SU_Values.iCurrentDeg;	// holt sich erstmal den Referenzwert in °, damit ich weiß, ob ich mich gedreht hab
	long degree = cm * (MU_GLOBAL_DRIVE1);	// den fehler von 1/3 grad braucht man hier nicht betrachten, da ich auf eine strecke von 2,5m eine abweichung von knapp 7° hab und das 3mm entspricht -> so genau lässt sich eh nicht regeln
	long counter = 0;
	long speed = 20;

	if(special_test == true)
	{
		while(true)
		{
			counter++;
			RotateMotorEx(GLOBAL_MOTOR12,MU_GLOBAL_MINSPEED,MU_GLOBAL_DEGREE_ONESTEP,0,false,false);

			// if(something)
			//    schmeiß event und brich while ab
			// 	  funktion wird automatisch beendet

		}
		return true;
	}


	bool testing_StopandGo;
	long degree_tostart = MU_GLOBAL_STOPandGO;

	if((degree - (2*MU_GLOBAL_STOPandGO)) > 0 )	// erstmal testen, ob mir der weg zum beschleunigen und normal bremsen reicht
	{
		degree = degree - (2*MU_GLOBAL_STOPandGO);	// erstmal die grad anpassen, die ich mit maximalgeschwindigkeit geradeausfahre
		testing_StopandGo = true;
	}
	else     	// wenn der weg nicht reicht(jetzt kleiner als 800°), dann nehm ich mir genauso viel zeit zum beschleunigen wie zum stoppen
	{
		testing_StopandGo = false;
		degree_tostart = degree/2;
	}

	long help_degree = degree_tostart;
	counter = 0;
	while(true)	// beschleunigung
	{
		counter++;
		if(help_degree > MU_GLOBAL_DEGREE_ONESTEP)	// solange mein noch zu fahrender Winkel größer ist als 50°
		{
			RotateMotorEx(GLOBAL_MOTOR12,speed,MU_GLOBAL_DEGREE_ONESTEP,0,false,false);	// fahre
			speed += MU_lokal_Beschleunigung;	// erhöhe die Geschwindikeit um eine fest Konstante
			help_degree -= MU_GLOBAL_DEGREE_ONESTEP;	// außerdem erniedrigen wir den noch zu fahrenden Winkel um den gefahrenen Winkel
			if(speed > MU_GLOBAL_MAXSPEED)	// sollte die geschwindigkeit höher als maximalgeschwindigkeit sein
			{
				speed = MU_GLOBAL_MAXSPEED;	// speed auf die maximale stellen
				RotateMotorEx(GLOBAL_MOTOR12,speed,help_degree,0,false,false);	// und die restlichen Grad abfahren
				break;	// dann mit der beschleunigung aufhören
			}
		}
		else      // das ist der Fall, wenn ich die maximalgeschwindigkeit nicht ganz erreicht habe, dann fahr ich einfach nur die restlichen Grad noch fertig ab
		{
			RotateMotorEx(GLOBAL_MOTOR12,speed,degree_tostart,0,false,false);	// um die restlichen Grad ausgleichen
		}
	}

	counter = 0;
	while(testing_StopandGo == true)	// fall, wenn ich mit maximalgeschwindigkeit vorwärts fahren will
	{
		counter++;
		if(degree > MU_GLOBAL_DEGREE_ONESTEP)	// solange wie der noch zu fahrende Winkel größer ist als 50°
		{
			RotateMotorEx(GLOBAL_MOTOR12,MU_GLOBAL_MAXSPEED,MU_GLOBAL_DEGREE_ONESTEP,0,false,false);
			degree -= MU_GLOBAL_DEGREE_ONESTEP;
		}
		else
		{
			RotateMotorEx(GLOBAL_MOTOR12,MU_GLOBAL_MAXSPEED,degree,0,false,false);	// die letzten paar Grad noch ausfahren und dann
			break;		// abbrechen
		}
	}

	help_degree = degree_tostart;
	counter = 0;
	long freq_brems = help_degree / (speed - 25);	// ich rechne mir erstmal aus, wie oft ich langsamer werden muss, damit für die restlichen grad noch so ca. 25% pwr da sind
	while(true) // bremsung
	{
		counter++;
		if(help_degree > MU_GLOBAL_DEGREE_ONESTEP)	// wenn ich noch mehr als 50° zu fahren hab
		{
			RotateMotorEx(GLOBAL_MOTOR12,speed,MU_GLOBAL_DEGREE_ONESTEP,0,false,false);
			speed -= freq_brems;	// die geschwindigkeit umd oben kleiner machen
			help_degree -= MU_GLOBAL_DEGREE_ONESTEP;	// außerdem den noch zu fahrenden winkel kleiner machen
			if(speed < 25)		// vorsichtshalber: ausstiegsbedingung, sollte ich iwas falsch gerechnet haben
			{
				RotateMotorEx(GLOBAL_MOTOR12,25,help_degree,0,false,true);
				break;
			}
		}
		else
		{
			RotateMotorEx(GLOBAL_MOTOR12,25,help_degree,0,false,true);
		}

	}

	Wait(20);
	Event_clearEvent(GLOBAL_EVENT_MU_READING);
}

bool MU_start_all_features()
{
	global_someth_exist = false;
	global_Dig0 = SU_Values.iCurrentDeg;

	MU_data_info.MU_x_pos = MU_GLOBAL_X_0;
	MU_data_info.MU_y_pos = MU_GLOBLAL_Y_0;
	MU_data_info.MU_angle = MU_GLOBAL_ANGLE_0;
	MU_data_info.MU_sin_angle = 0;
	MU_data_info.MU_distance = 0;

#ifdef MU_feedback
	PlayTone(100,50);
#endif MU_feedback

	StartTask(MU_informations);
}

task MU_informations()
{
#ifdef MU_feedback
	PlayTone(1000,50);
#endif MU_feedback
	while(true)
	{
		MU_data_info.MU_angle = (SU_Values.iCurrentDeg - global_Dig0);
		if(MU_data_info.MU_angle < 0)
		{
			MU_data_info.MU_angle += 360;	// somit habe ich immer einen positiven Winkel bezogen auf die Karte
#ifdef MU_debug
			TextOut(1,LCD_LINE1,"Winkel im Raum");
			NumOut(1,LCD_LINE2, MU_data_info.MU_angle);
#endif MU_debug
		}
		if(Event_eventIsPresent(GLOBAL_EVENT_MU_READING))
		{
			// die informationen hier haben natürlich im moment keine aussagekraft, da diese sich darauf verlassen, dass wir uns vernünftig bewegen...
			int pos_changing = ((MotorTachoCount(GLOBAL_MOTOR1) + MotorTachoCount(GLOBAL_MOTOR2)) / 2);
			int help = pos_changing % 2;	// liefert mir den Rest zurück, den ich mich noch im Feld befinde in °
			pos_changing /= MU_GLOBAL_WHEEL;	// liefert mir die Veränderung in der entsprechenden Richtung zurück

			// TODO: entfernung und angle dazwischen jeweils ausrechnen, falls benötigt
			if(MU_data_info.MU_angle == 90)	// wenn der Roboter nach links schaut(auf der Karte)
			{
				MU_data_info.MU_x_pos -= pos_changing;
			}
			else if(MU_data_info.MU_angle == 180)	// wenn der Roboter nach oben schaut(auf der Karte)
			{
				MU_data_info.MU_y_pos -= pos_changing;
			}
			else if(MU_data_info.MU_angle == 270)	// wenn der Roboter auf der Karte nach rechts schaut
			{
				MU_data_info.MU_x_pos += pos_changing;
			}
			else if(MU_data_info.MU_angle == 0)	// wenn der Roboter, wie initial bestimmt, nach unten schaut
			{
				MU_data_info.MU_y_pos += pos_changing;
			}
			else            			// wenn der Roboter in keinem der angepassten Winkel steht, dann muss ich in einen entsprechenden Winkel reinfahren und dann nochmal anfangen
			{
				// else fall noch ausprogrammieren
			}
		}

	}

}

#ifdef MU_debug
task main()
{

}
#endif MU_debug

#endif ___MOTORMODULE___