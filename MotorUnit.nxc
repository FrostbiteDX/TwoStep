#ifndef ___MOTORMODULE___
#define ___MOTORMODULE___

/*******************************
 * MotorModule
 *
 * author: Florian Laufenböck
 * *****************************/



/*******************************
 * Information:
 *******************************/
 // to start the MototModule call only  MU_start_all_features() !
 // der Fehler bei der Fahrt beträgt bei gefahrenen 2000° ca. 2°
 // -> immer aufrunden oder immer abrunden?
/*******************************
 * Beispielkarte der Umgebung:
 *
     0123456789....
	0##############
	1#	  S	      #
	2##   #####   #
	3#	  11 	  #
	4#			  #
	5#   ####    2#
	6#	    #    2#
	7#	    #     #
	8#   ##########
	9#   #        #
	 #   #   33   #
	 #   #        #
	 #            #
	 ##############
	------------->x - koordinate
    und von up to down ist y-koordinate
    -> S = 5/1
    außerdem gilt: der Startwinkel ist entlang der positiven y achse, sodass beim Start vom Roboter aus vorne 0° sind
    *
    *
    **************************/



/*******************************
 * Includes
 *******************************/
// needs the SensorModule, because of the compass
#include "SensorModule.nxc"
#include "TimersAndEvents.nxc"


/*******************************
 * Declaration
 *******************************/

/* struct _MU_data
 *
 * unsigned int MU_x_pos:	liefert die aktuelle x-position des Fahrzeugs allein aufgrund der Odometrie zurück
 * unsigned int MU_y_pos: 	liefert die aktuelle y-position des Fahrzeugs allein aufgrund der Odometrie zurück
 * unsigned int MU_angle:	liefert den Winkel zurück, in dem das Fahrzeug im Raum steht, zurück
 *
 * short MU_sin_angle:		liefert den Winkel zurück, der zwischen der Gerade, die die Startposition mit der aktuellen Position verbindet, und der y-Achse zurück
 * float MU_distance:		liefert den abstand(luftlinie) zum Start zurück; benutzt dafür x-pos, y-pos
 */
/*struct _MU_data
{
	unsigned int MU_x_pos;
	unsigned int MU_y_pos;
	long MU_angle;

	long MU_sin_angle;
	float MU_distance;
};
*/
//long global_Dig0;	// das ist der winkel, der "0" ist, also der 0 winkel von dem ich alles brauche, wichtig: NUR BEIM START INITIAL BELEGEN
long global_winkel_todrive;	// brauch ich um zwischen den tasks und meiner fahrfunktion kommunizieren zu können, damit ich immer bestimmte ° abfahre

/* function: MU_drive_forward
 * gets: weg in cm der zurückgelegt werden muss
 * fährt den Weg in cm ab, fährt nur geradeaus, sodass keine komplexen Bewegungen entstehen
 * hat einen special_mode mit dem ich einfach so lange fahren kann, wie ich will (bzw. Event wird geworfen...)
 * liefert false zurück, wenn iwas schiefgegangen ist(hinderniss, lange keine signal, bin auf farbe gesstossen)
 * schmeißt am Ende der Ausführung ein Event, sodass der Tachometer gelöscht werden kann
 */
void MU_drive_forward(const short &cm);

/* functin: MU_drive_backward
 * gets: weg in cm, der zurückgelegt werden soll
 * fährt den weg rückwärts ab, keine komplexen Bewegungen
 * hat einen special_mode mit dem ich einfach so lange fahren kann, wie ich will (bzw. Event wird geworfen...)
 * ruft einfach nur MU_drive_forward mit negativen Wert auf
 *  liefert false zurück, wenn iwas schiefgegangen ist(hinderniss, lange keine signal, bin auf farbe gesstossen)
 * schmeißt am Ende der Ausführung ein Event, sodass der Tachometer gelöscht werden kann
 */
void MU_drive_backward(const short &cm);

/* function: MU_drehen_by_angle
 * gets: den Winkel den er sich drehen soll(positiv oder negativ)
 * 											wobei: positiv = in Uhrzeigersinnn, negativ = gegen Uhrzeigersinn
 * dreht sich um den Winkel um die eigene Achse, sodass der Mittelpunkt des Robos immer gleich ist
 *  liefert false zurück, wenn iwas schiefgegangen ist(hinderniss, lange keine signal, bin auf farbe gesstossen)
 * nach fertigem drehen wird der Tachocounter gelöscht!!!!
 */
void MU_drehen_by_angle(const short &angle);

/*function: MU_start_all_featurs
 * kriegt keine Variablen
 * testet ob beide Motoren in A und C eingesteckt sind
 * startet den Task MU_informations
 * liefert false zurück, sollte iwas nicht wie gewünscht laufen
 */
void MU_start_all_features();

/* Task: MU_motor1
 * fährt mit Motor1 einen fest definierten Weg ab
 */
task MU_motor1();

/* Task: MU_motor2
 * fährt mit Motor2 einen fest definierten Weg ab
 */
task MU_motor2();


/******************************
 * Defines:
 ******************************/

#define GLOBAL_1_SEKTOR 25	// definition wie groß ein Sektor im Raum ist
#define MU_GLOBAL_ANGLE_MOTOR 360	// Winkel, damit sich das Rad einmal dreht
#define MU_GLOBAL_UMFANG 13.5	// umfang des Rades
#define MU_GLOBAL_DRIVE1 (MU_GLOBAL_ANGLE_MOTOR / MU_GLOBAL_UMFANG) 	// Winkel um einen cm zurückzulegen
#define MU_GLOBAL_WHEEL	(MU_GLOBAL_DRIVE1 * GLOBAL_1_SEKTOR)	// Winkel um 25cm zurückzulegen
#define MU_GLOBAL_MAXSPEED 50
#define MU_GLOBAL_DEGREE_ONESTEP 10		// gibt die Grad an, die ich bei einer Umdrehung fahren will
#define GLOBAL_MOTOR1 OUT_A
#define GLOBAL_MOTOR2 OUT_C
#define GLOBAL_MOTOR12 OUT_AC
#define MU_GLOBAL_FEHLERKORREKTUR 7	// um wie viel Grad muss ich einen motor auf einer Seite bewegen, um den KompassSensor um 1 Grad zu korriegeren?
#define MU_LOKAL_DIFFRENCE_MOTOR12 7	// der unterschied, den motor A weniger power hat als Motor C, kann hier global eingestellt werden
#define MU_LOKAL_INSTEPS	67	

/******************************
 * Debugs
 * using LCD_LINE 1 and 2
 ******************************/
 #define MU_debug	// debug klausel
 #define MU_feedback	// klausel, die bestimmt, wann feedback vom Robo nach außen gegeben wird
 #define MU_mitausgleich


/*******************************
 * Timer and Events for the Motormodule
 ******************************/
#define GLOBAL_EVENT_MU_CANDRIVE1 0x80	// event, wenn motor1 fahren kann
#define GLOBAL_EVENT_MU_CANDRIVE2 0x40	// event, wenn motor2 fahren kann
#define GLOBAL_EVENT_MU_CANACT1   0x20	// event, wenn motor1 fertig ist mit fahren
#define GLOBAL_EVENT_MU_CANACT2   0x10	// event,wenn motor2 fertig ist mit fahren


/*******************************
 * Initialisation
 ******************************/


/*******************************
 *Functions and tasks
 *******************************/

void MU_drehen_by_angle(const short &angle)
{
	// es gilt: ein positiver winkel bedeutet, dass der Robo sich im Uhrzeigersinn dreht, bedeutet in Fahrtrichtung nach rechts
	// das wiederum bedeutet, dass der Roboter, um sich auf der Stelle zu drehen, den einen Motor in positiver Richtung
	// und den anderen Motor in negativer Richtung ansteuern muss -> um im Uhrzeigersinn: MotorA negativ, MotorC positiv
	// sonst andersrum
	//	lösung vorerst: einfach mit RotateMotorEx und der geeigneteten Konstante versuchen das Ding zu drehen
	// alternativ: Erst den einen Motor, dann den anderen Motor	(von den alternativen zu bevorzugen, wenns der robo so machen darf...)
	// alterantiv2: über tasks, dann wird die ganze sache aber rel. kompliziert da vorzeichenwechsel und zwei globale variablen etc... 
	RotateMotorEx(GLOBAL_MOTOR12,MU_GLOBAL_MAXSPEED,angle,100,false,true);	// diese funktion muss man erst noch richtig testen
}

void MU_start_all_features()
{
	Event_clearEvent(GLOBAL_EVENT_MU_CANDRIVE1);
	Event_clearEvent(GLOBAL_EVENT_MU_CANDRIVE2);
	Event_clearEvent(GLOBAL_EVENT_MU_CANACT1);
	Event_clearEvent(GLOBAL_EVENT_MU_CANACT2);
	StartTask(MU_motor1);
	StartTask(MU_motor2);
	Wait(10);
}

void MU_drive_backward(const short &cm)
{
	MU_drive_forward(-cm);
}

void MU_drive_forward(const short &cm)
{
	ResetRotationCount(GLOBAL_MOTOR12);	// beide Motoren reseten
	
	bool vorwaerts;
	if(cm > 0)	// damit kann man auch drive_forward negative werte übergeben und es funktioniert immer
		vorwaerts = true;
	else
		vorwaerts = false;
	global_winkel_todrive = MU_GLOBAL_WHEEL;	// erstmal den Winkel initialisieren, damit ich weiß, wie oft ich 25cm vorwärts fahr
	long degree_to_drive = cm * MU_GLOBAL_DRIVE1;	// erstmal ausrechnen wie weit ich fahren muss
	short dig0_here = SU_Values.iCurrentDeg;	// holt sich erstmal den Referenzwert in °, damit ich weiß, ob ich mich gedreht hab in abhängigkeit vom kompass

	while(vorwaerts)	// mit dieser Schleife fahr ich solange immer 25cm ab, bis die noch zu fahrende Strecke kleiner als 25cm ist
	{
		if(degree_to_drive < MU_GLOBAL_WHEEL) 	// mit dieser Funktion fahre ich am Ende der fahrt die restlichen Grad ab, die man noch abzufahren ist
		{
			if((!Event_eventIsPresent(GLOBAL_EVENT_MU_CANACT1)) | (!Event_eventIsPresent(GLOBAL_EVENT_MU_CANACT2)))	// warten bis die Motoren mit dem aktuellen Fahren fertig sind
			{
				global_winkel_todrive = degree_to_drive;	// die restlichen Grad in die globale Var schreiben
				Event_setEvent(GLOBAL_EVENT_MU_CANDRIVE1);	// die beiden Motoren nochmal anstossen
				Event_setEvent(GLOBAL_EVENT_MU_CANDRIVE2);
				break;	// und fertig mim vorwärtsfahren
			}	
			
		}
		else if((!Event_eventIsPresent(GLOBAL_EVENT_MU_CANACT1)) | (!Event_eventIsPresent(GLOBAL_EVENT_MU_CANACT2)))	// wenn beide Motoren gerade inaktiv sind
		{
			Event_setEvent(GLOBAL_EVENT_MU_CANDRIVE1);	// dann werden beide motorevents angschmissen,sodass die motoren mit ihrem Winkel anfangen zu fahren
			Event_setEvent(GLOBAL_EVENT_MU_CANDRIVE1);
			degree_to_drive -= global_winkel_todrive;	// und dann noch den abgefahrenen grad von den zu fahrendem grad abziehen
		}		
	}
	while(!vorwaerts)	// fürs rückwärtsfahren, damit ich das alles in einer funktion hab, und die aufrufe von vorwärts und rückwärts fahren einfacher werden
	{
		if(degree_to_drive > -MU_GLOBAL_WHEEL) 	// mit dieser Funktion fahre ich am Ende der fahrt die restlichen Grad ab, die man noch abzufahren ist
		{
			if((!Event_eventIsPresent(GLOBAL_EVENT_MU_CANACT1)) | (!Event_eventIsPresent(GLOBAL_EVENT_MU_CANACT2)))	// warten bis die Motoren mit dem aktuellen Fahren fertig sind
			{
				global_winkel_todrive = degree_to_drive;	// die restlichen Grad in die globale Var schreiben
				Event_setEvent(GLOBAL_EVENT_MU_CANDRIVE1);	// die beiden Motoren nochmal anstossen
				Event_setEvent(GLOBAL_EVENT_MU_CANDRIVE2);
				break;	// und fertig mim vorwärtsfahren
			}	
			
		}
		else if((!Event_eventIsPresent(GLOBAL_EVENT_MU_CANACT1)) | (!Event_eventIsPresent(GLOBAL_EVENT_MU_CANACT2)))	// wenn beide Motoren gerade inaktiv sind
		{
			Event_setEvent(GLOBAL_EVENT_MU_CANDRIVE1);	// dann werden beide motorevents angschmissen,sodass die motoren mit ihrem Winkel anfangen zu fahren
			Event_setEvent(GLOBAL_EVENT_MU_CANDRIVE1);
			degree_to_drive += global_winkel_todrive;	// und dann noch den abgefahrenen grad von den zu fahrendem grad abziehen
		}		
	}

#ifdef MU_debug
	NumOut(1,LCD_LINE1,degree_to_drive);
#endif MU_debug

}

task MU_motor1()
{	
	if(Event_eventIsPresent(GLOBAL_EVENT_MU_CANDRIVE1))
	{
		Event_clearEvent(GLOBAL_EVENT_MU_CANDRIVE1);
		Event_setEvent(GLOBAL_EVENT_MU_CANACT1);
		long to_drive = global_winkel_todrive;
		while(true)	
		{
			RotateMotorEx(GLOBAL_MOTOR1,MU_GLOBAL_MAXSPEED+MU_LOKAL_DIFFRENCE_MOTOR12,MU_GLOBAL_DEGREE_ONESTEP,0,false,false);
			to_drive -= MU_GLOBAL_DEGREE_ONESTEP;
			if(to_drive < 0)
				break;
			Wait(10);
		}
		Event_clearEvent(GLOBAL_EVENT_MU_CANACT1);	// wenn der Motor fertig ist mit fahren, weil er den to_drive winkel abgefahren hat, dann kann ich starten	
	}
}

task MU_motor2()
{
	if(Event_eventIsPresent(GLOBAL_EVENT_MU_CANDRIVE2))
	{
		Event_clearEvent(GLOBAL_EVENT_MU_CANDRIVE2);
		Event_setEvent(GLOBAL_EVENT_MU_CANACT2);	// jetzt setze ich ein Event, dass ich fahre
		long to_drive = global_winkel_todrive;	// über diese Variable kann ich jede beliebige Strecke abfahren
		while(true)	
		{
			RotateMotorEx(GLOBAL_MOTOR1,MU_GLOBAL_MAXSPEED,MU_GLOBAL_DEGREE_ONESTEP,0,false,false);
			to_drive -= MU_GLOBAL_DEGREE_ONESTEP;
			if(to_drive < 0)
				break;
			Wait(10);
		}
		Event_clearEvent(GLOBAL_EVENT_MU_CANACT1);	// wenn dieser Motor seinen ganzen Winkel abgefahren hat, dann löscht er dass "ich fahre event"
	}
}

#ifdef MU_debug
task main()
{
	SU_InitSensors(200);
	Wait(10);
	MU_start_all_features();
	// ab hier kann ich ab jetzt ganz normal fahren
}
#endif MU_debug

#endif ___MOTORMODULE___
