#ifndef __SENSOR_MODULE__
#define __SENSOR_MODULE__

//******************************************************
// Sensor Module
//
// Authors: Alexander Strobl, Daniel Tatzel
//******************************************************

//******************************************************
// Declarations
//******************************************************

short SU_TempCompassRef = 0;
short SU_InitCompassValue = 0;

// Different mutex to prevent reading while the values get updated
mutex MutexColor;
mutex MutexUSonic;
mutex MutexCmps;

/* struct _SU_Values
	- Stores all relevant sensor values
	- Compass section:
		iCurrentDeg: 			Current direction in degrees

	- Color section:
		byMeasuredColor:		Current color value
		byTargetColor:			Color of the target table
		byTargetColorFound: 	1 if the robot found the target table (default: 0)

	- Ultrasonic section:
		iDistance_Front:		Current distance to an object of the front sensor
		iDistance_Back:			Current distance to an object of the back sensor

	- Miscellaneous section:
		iInterval:				Refresh intervall of the sensor values

*/
struct _SU_Values
{
  // Compass
  unsigned int iCurrentDeg;

  // Color
  byte byMeasuredColor;
  byte byTargetColor;
  byte byTargetColorFound;

  // Ultrasonic
  unsigned int iDistance_Front;
  unsigned int iDistance_Back;

  // Miscellaneous
  unsigned int iInterval;
};

/* Function: SU_InitSensors
	- Initializes all Sensors (RGB, ultrasonic and compass), must be called from the main task
	- Variable iReadingIntervall:	Sets the refresh intervall of the sensor values
*/
unsigned int SU_InitSensors(unsigned int iReadingInterval);

/* Task: SU_CheckDistances
	- Reads the distance values of both ultrasonic sensors
*/
task SU_CheckDistances();

/* Task: SU_CheckColors
	- Reads the color value of the RGB sensor
	- Sets the variable "byTargetColorFound" in the sruct _SU_Values to 1 if the robot found the target table
*/
task SU_CheckColors();

/* Task: SU_CheckCompass
	- Reads the current direction of the compass sensor
*/
task SU_CheckCompass();

/* Task: SU_ReadSensors
	- Starts all sensor tasks
*/
task SU_ReadSensors();



//******************************************************
// Includes
//******************************************************

// Compass library. Must be in the main directory
#include "IMU-lib.nxc"

#include "MapModule.nxc"



//******************************************************
// Defines
//******************************************************

#define SU_ADDR              	0x22
#define SU_COMPASS_SENSOR_PORT 	S1
#define SU_COLOR_SENSOR       	S2
#define SU_SONIC_FRONT       	S3
#define SU_SONIC_BACK        	S4
#define SU_SONIC_RADIUS			50

// Turn display messages on / off
#define SU_SENSOR_DEBUG


//******************************************************
// Definitions
//******************************************************

// Struct
_SU_Values SU_Values;

//#include "MotorUnit.nxc"

//******************************************************
// Functions and tasks
//******************************************************


task SU_DisplayOutput( )
{
    while( true )
    {
    TextOut( 0,LCD_LINE1, "D: " );
    NumOut( 40,LCD_LINE1, SU_Values.iCurrentDeg );

    TextOut( 0,LCD_LINE2, "C: " );
    NumOut( 40,LCD_LINE2, SU_Values.byMeasuredColor );

    TextOut( 0,LCD_LINE3, "USF: " );
    NumOut( 40,LCD_LINE3, SU_Values.iDistance_Front );

    TextOut( 0,LCD_LINE4, "USB: " );
    NumOut( 40,LCD_LINE4, SU_Values.iDistance_Back );
    Wait( SU_Values.iInterval );
    ClearScreen( );
    }
}

// Temp main for testing purposes, must be deleted!
/*
task main()
{
    SU_InitSensors(200);
}
*/

unsigned int SU_InitSensors(unsigned int iReadingInterval)
{
   // SU_COLOR_SENSOR
   Acquire( MutexColor );
   SetSensorColorFull(SU_COLOR_SENSOR);
   SU_Values.byMeasuredColor = 0;
   Release( MutexColor );

   // Compass
   Acquire( MutexCmps );
   IMU_Init(SU_COMPASS_SENSOR_PORT);
   SU_Values.iCurrentDeg = 0;

   SU_InitCompassValue = IMU_ReadCompassHeading( SU_COMPASS_SENSOR_PORT, SU_ADDR );
   if ( SU_InitCompassValue <= 180 )
	SU_InitCompassValue += 180;
   else
	SU_InitCompassValue -= 180;

   Release( MutexCmps );

   // UltraSonic

   // Front
   Acquire( MutexUSonic );
   SetSensorLowspeed( SU_SONIC_FRONT );
   SU_Values.iDistance_Front = 0;

   // Back
   SetSensorLowspeed( SU_SONIC_BACK );
   SU_Values.iDistance_Back = 0;
   Release( MutexUSonic );

   if( iReadingInterval != 0)
       SU_Values.iInterval = iReadingInterval;
   else
       SU_Values.iInterval = 200;

   StartTask(SU_ReadSensors);
   return 0;
}

task SU_CheckDistances()
{
   while(1)
   {
      // Front Sensor
      Acquire( MutexUSonic );
      SU_Values.iDistance_Front = SensorUS ( SU_SONIC_FRONT );

      // Back Sensor
      SU_Values.iDistance_Back = SensorUS ( SU_SONIC_BACK );
      Release( MutexUSonic );

      Wait(SU_Values.iInterval);
   }
}


task SU_CheckColors()
{
  ColorSensorReadType csr;
  csr.Port = SU_COLOR_SENSOR;

  while (1)
  {
     Acquire( MutexColor );
     SysColorSensorRead(csr);
     if (csr.Result == NO_ERR)
     {
        SU_Values.byMeasuredColor = csr.ColorValue;

        // Event setzen
        if(csr.ColorValue == SU_Values.byTargetColor)
            SU_Values.byTargetColorFound = 1;
        else
            SU_Values.byTargetColorFound = 0;
     }
     Release ( MutexColor );

     Wait(SU_Values.iInterval);
  }
}

task SU_CheckCompass()
{
   while( true )
   {
      Acquire ( MutexCmps );
      unsigned int x = 0;
      int heading = 0;

      SU_Values.iCurrentDeg = IMU_ReadCompassHeading( SU_COMPASS_SENSOR_PORT, SU_ADDR );
      Release ( MutexCmps );

      Wait( SU_Values.iInterval );
   }
}


task SU_ReadSensors()
{
   Precedes(SU_CheckDistances, SU_CheckColors, SU_CheckCompass
   #ifdef SU_SENSOR_DEBUG
   , SU_DisplayOutput
   #endif /* SU_SENSOR_DEBUG */
   );
}
/*
task SU_CheckObstacle( )
{
	while ( true )
	{
		if ( SU_CriticalDistance >= SU_Values.iDistance_Front )
		{

			// Something went wrong throw stop event!!


		}

	}
}
*/
unsigned short SU_AddCompassValue( short orientation, short Offset )
{
	int help = orientation + Offset;

	if ( help >= 360 )
		help -= 360;

	if ( help < 0 )
		help += 360;

	return help;
}

short SU_GetAzimuth( short degree )
{
	return degree - 360 - SU_Values.iCurrentDeg;
}

void SU_Measuring( byte FieldRange_front, byte FieldRange_back)
{
		// Pruefen ob Hindernis in Reichweite ist
		if ( ( FieldRange_front * GLOBAL_1_SEKTOR ) >= SU_SONIC_RADIUS )
		{
			until(!MutexUSonic);
			SU_Values.iDistance_Front = SensorUS ( SU_SONIC_FRONT );

			// Verarbeitung Starten (Bedenken: Wird Rueckgabewert bedingt? Wenn ja, diese Funktion trennen, wegen Rueckgabewerte
			//SU_Values.iDistance_Front;
		}

		if ( ( FieldRange_back * GLOBAL_1_SEKTOR ) >= SU_SONIC_RADIUS )
		{
			until(!MutexUSonic);
			SU_Values.iDistance_Back = SensorUS ( SU_SONIC_BACK );

			//SU_Values.iDistance_Back;
		}
}

int SU_PosCalibration( byte xpos, byte ypos, short orientation )
{

    byte tmpx = xpos;
	byte tmpy = ypos;
	byte FieldRange_front = 0;
	byte FieldRange_back = 0;
	byte obstacle_front = 0;
	byte obstacle_back = 0;


		if ( 0 == orientation || 180 == orientation ) // Nord & Sued Ausrichtung
        {
            while ( true )
            {
                if ( g_MapModule_WorkField.map[GLOBAL_MAP_WIDTH * tmpy + xpos] == '#')
				{
					tmpy++;
					if ( 0 == orientation )
					{
						obstacle_front = 1;
						FieldRange_front = ( ypos - tmpy ); // * GLOBAL_1_SEKTOR;
					}
					else if ( 180 == orientation )
					{
						obstacle_back = 1;
						FieldRange_back = ( ypos - tmpy ); // * GLOBAL_1_SEKTOR;
					}
                    break;
				}
				tmpy--;
            }

            while ( true )
            {
                if ( '#' == g_MapModule_WorkField.map[GLOBAL_MAP_WIDTH * tmpy + xpos] )
				{
					tmpy--;
					if ( 0 == orientation )
					{
						obstacle_back = 1;
						FieldRange_back = ( ypos - tmpy ); // * GLOBAL_1_SEKTOR;
					}
					else if ( 180 == orientation )
					{
						obstacle_front = 1;
						FieldRange_front = ( ypos - tmpy ); // * GLOBAL_1_SEKTOR;
					}
                    break;
				}
				++tmpy;
            }
        }

        if ( 90 == orientation || 270 == orientation ) // Ost & West Ausrichtung
        {
            while ( true )
            {
                if ( '#' == g_MapModule_WorkField.map[GLOBAL_MAP_WIDTH * ypos + tmpx] )
				{
					xpos++;
					if ( 90 == orientation )
					{
						obstacle_back = 1;
						FieldRange_back = ( xpos - tmpx ); // * GLOBAL_1_SEKTOR;
					}
					else if (270 == orientation )
					{
						obstacle_front = 1;
						FieldRange_front = ( xpos - tmpx ); // * GLOBAL_1_SEKTOR;
					}
                    break;
				}
				--tmpx;
            }

            while ( true )
            {
                if ( '#' == g_MapModule_WorkField.map[GLOBAL_MAP_WIDTH * ypos + tmpx] )
				{
					xpos--;
					if ( 90 == orientation )
					{
						obstacle_front = 1;
						FieldRange_front = ( xpos - tmpx ); // * GLOBAL_1_SEKTOR;
					}
					else if ( 270 == orientation )
					{
						obstacle_back = 1;
						FieldRange_back = ( xpos - tmpx ); // * GLOBAL_1_SEKTOR;
					}
                    break;
				}
				++tmpx;
            }

        }


		unsigned short degree = SU_AddCompassValue( orientation, SU_InitCompassValue );

		if ( degree != SU_Values.iCurrentDeg )
		{
			short degreetoturn = SU_GetAzimuth( degree );

			MU_drehen_by_angle( degreetoturn );
		}

		SU_Measuring( FieldRange_front, FieldRange_back );







		//SU_TempCompassRef
}

#endif



